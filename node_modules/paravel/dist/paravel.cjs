"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  EventBus: () => EventBus,
  Executor: () => Executor,
  Plex: () => Plex,
  Pool: () => Pool,
  Relay: () => Relay,
  Relays: () => Relays,
  Socket: () => Socket,
  defer: () => defer
});
module.exports = __toCommonJS(main_exports);

// src/util/EventBus.ts
var _EventBus = class {
  listeners = {};
  addListener(name, handler) {
    this.listeners[name] = this.listeners[name] || [];
    this.listeners[name].push(handler);
    return () => this.removeListener(name, handler);
  }
  addListeners(config) {
    const callbacks = [];
    for (const [name, handler] of Object.entries(config)) {
      callbacks.push(this.addListener(name, handler));
    }
    return () => callbacks.forEach((unsubscribe) => unsubscribe());
  }
  removeListener(name, handler) {
    this.listeners[name] = (this.listeners[name] || []).filter((h) => h !== handler);
  }
  clear() {
    this.listeners = {};
  }
  emit(k, ...payload) {
    for (const handler of this.listeners[k] || []) {
      handler(...payload);
    }
    for (const handler of this.listeners[_EventBus.ANY] || []) {
      handler(k, ...payload);
    }
  }
};
var EventBus = _EventBus;
__publicField(EventBus, "ANY", Math.random().toString().slice(2));

// src/util/Deferred.ts
var defer = () => {
  let resolve, reject;
  const p = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return Object.assign(p, { resolve, reject });
};

// src/util/Socket.ts
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var _Socket = class {
  ws;
  url;
  ready;
  timeout;
  queue;
  bus;
  status;
  error;
  _onOpen;
  _onMessage;
  _onError;
  _onClose;
  constructor(url) {
    this.url = url;
    this.ready = defer();
    this.queue = [];
    this.bus = new EventBus();
    this.status = _Socket.STATUS.NEW;
    this._onOpen = () => {
      this.error = void 0;
      this.status = _Socket.STATUS.READY;
      this.ready.resolve();
      this.bus.emit("open");
    };
    this._onMessage = (event) => {
      this.queue.push(event.data);
      if (!this.timeout) {
        this.handleMessagesAsync();
      }
    };
    this._onError = (error) => {
      this.error = error;
      this.bus.emit("error", error);
    };
    this._onClose = () => {
      this.disconnect();
      this.ready.reject();
      this.status = _Socket.STATUS.CLOSED;
      this.bus.emit("close");
    };
  }
  async connect() {
    if ([_Socket.STATUS.NEW, _Socket.STATUS.CLOSED].includes(this.status)) {
      if (this.ws) {
        console.error("Attempted to connect when already connected", this);
      }
      this.ready = defer();
      this.ws = new import_isomorphic_ws.default(this.url);
      this.status = _Socket.STATUS.PENDING;
      this.ws.addEventListener("open", this._onOpen);
      this.ws.addEventListener("message", this._onMessage);
      this.ws.addEventListener("error", this._onError);
      this.ws.addEventListener("close", this._onClose);
    }
    await this.ready.catch(() => null);
  }
  disconnect() {
    if (this.ws) {
      const ws = this.ws;
      this.ready.then(() => ws.close(), () => null);
      this.ws.removeEventListener("open", this._onOpen);
      this.ws.removeEventListener("message", this._onMessage);
      this.ws.removeEventListener("error", this._onError);
      this.ws.removeEventListener("close", this._onClose);
      this.ws = void 0;
    }
  }
  cleanup() {
    this.disconnect();
    this.bus.clear();
  }
  handleMessages() {
    for (const json of this.queue.splice(0, 10)) {
      let message;
      try {
        message = JSON.parse(json);
      } catch (e) {
        continue;
      }
      this.bus.emit("message", this.url, message);
    }
    if (this.queue.length > 0) {
      this.handleMessagesAsync();
    } else {
      this.timeout = void 0;
    }
  }
  handleMessagesAsync() {
    this.timeout = setTimeout(() => this.handleMessages(), 10);
  }
  send(message) {
    if (this.status === _Socket.STATUS.READY) {
      if (this.ws?.readyState !== 1) {
        console.warn("Send attempted before socket was ready", this);
      }
      this.ws?.send(JSON.stringify(message));
    }
  }
};
var Socket = _Socket;
__publicField(Socket, "STATUS", {
  NEW: "new",
  PENDING: "pending",
  CLOSED: "closed",
  READY: "ready"
});

// src/Executor.ts
var createFilterId = (filters) => [Math.random().toString().slice(2, 6), filters.map(describeFilter).join(":")].join("-");
var describeFilter = ({ kinds = [], ...filter }) => {
  const parts = [];
  parts.push(kinds.join(","));
  for (const [key, value] of Object.entries(filter)) {
    if (value instanceof Array) {
      parts.push(`${key}[${value.length}]`);
    } else {
      parts.push(key);
    }
  }
  return "(" + parts.join(",") + ")";
};
var Executor = class {
  target;
  constructor(target) {
    this.target = target;
  }
  subscribe(filters, { onEvent, onEose }) {
    const id = createFilterId(filters);
    const unsubscribe = this.target.bus.addListeners({
      EVENT: (url, subid, e) => subid === id && onEvent?.(url, e),
      EOSE: (url, subid) => subid === id && onEose?.(url)
    });
    this.target.send("REQ", id, ...filters);
    return {
      unsubscribe: () => {
        this.target.send("CLOSE", id);
        unsubscribe();
      }
    };
  }
  publish(event, { onOk, onError }) {
    const unsubscribe = this.target.bus.addListeners({
      OK: (url, id, ...payload) => id === event.id && onOk(url, ...payload),
      ERROR: (url, id, ...payload) => id === event.id && onError(url, ...payload)
    });
    this.target.send("EVENT", event);
    return { unsubscribe };
  }
  count(filters, { onCount }) {
    const id = createFilterId(filters);
    const unsubscribe = this.target.bus.addListeners({
      COUNT: (url, subid, ...payload) => {
        if (subid === id) {
          onCount(url, ...payload);
          unsubscribe();
        }
      }
    });
    this.target.send("COUNT", id, ...filters);
    return { unsubscribe };
  }
  handleAuth({ onAuth, onOk }) {
    let event;
    const unsubscribe = this.target.bus.addListeners({
      AUTH: async (url, challenge) => {
        event = await onAuth(url, challenge);
      },
      OK: (url, id, ok, message) => {
        if (id === event?.id) {
          event = null;
          onOk(url, id, ok, message);
        }
      }
    });
    return { unsubscribe };
  }
};

// src/Plex.ts
var Plex = class {
  constructor(urls, socket) {
    this.urls = urls;
    this.socket = socket;
    this.bus = new EventBus();
    this.unsubscribe = socket.bus.addListeners({
      message: (websocketUrl, [{ relays }, [verb, ...payload]]) => {
        this.bus.emit(verb, relays[0], ...payload);
      }
    });
  }
  async send(...payload) {
    await this.socket.connect();
    this.socket.send([{ relays: this.urls }, payload]);
  }
  cleanup() {
    this.bus.clear();
    this.unsubscribe();
  }
};

// src/Pool.ts
var Pool = class {
  data;
  constructor() {
    this.data = /* @__PURE__ */ new Map();
    this.bus = new EventBus();
  }
  has(url) {
    return this.data.has(url);
  }
  get(url) {
    if (!this.data.has(url)) {
      const socket = new Socket(url);
      this.data.set(url, socket);
      this.bus.emit("init", { url });
      socket.bus.addListeners({
        open: () => this.bus.emit("open", { url }),
        close: () => this.bus.emit("close", { url })
      });
    }
    return this.data.get(url);
  }
  remove(url) {
    const socket = this.data.get(url);
    if (socket) {
      socket.cleanup();
      this.data.delete(url);
    }
  }
  clear() {
    for (const url of this.data.keys()) {
      this.remove(url);
    }
  }
};

// src/Relay.ts
var Relay = class {
  constructor(socket) {
    this.socket = socket;
    this.bus = new EventBus();
    this.listeners = sockets.map((socket2) => {
      return socket2.bus.addListener("message", (url, [verb, ...payload]) => {
        this.bus.emit(verb, url, ...payload);
      });
    });
  }
  async send(...payload) {
    await this.socket.connect();
    this.socket.send(payload);
  }
  cleanup() {
    this.bus.clear();
    this.listeners.map((unsubscribe) => unsubscribe());
  }
};

// src/Relays.ts
var Relays = class {
  sockets;
  bus;
  constructor(sockets2) {
    this.sockets = sockets2;
    this.bus = new EventBus();
    this.listeners = sockets2.map((socket) => {
      return socket.bus.addListener("message", (url, [verb, ...payload]) => {
        this.bus.emit(verb, url, ...payload);
      });
    });
  }
  send(...payload) {
    this.sockets.forEach(async (socket) => {
      await socket.connect();
      socket.send(payload);
    });
  }
  cleanup() {
    this.bus.clear();
    this.listeners.map((unsubscribe) => unsubscribe());
  }
};
