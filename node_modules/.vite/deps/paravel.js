import {
  __publicField,
  _global,
  init_shim
} from "./chunk-VETBGRT7.js";

// node_modules/paravel/dist/paravel.esm.js
init_shim();

// node_modules/isomorphic-ws/browser.js
init_shim();
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof _global !== "undefined") {
  ws = _global.WebSocket || _global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/paravel/dist/paravel.esm.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _EventBus = class {
  constructor() {
    __publicField(this, "listeners", {});
  }
  addListener(name, handler) {
    this.listeners[name] = this.listeners[name] || [];
    this.listeners[name].push(handler);
    return () => this.removeListener(name, handler);
  }
  addListeners(config) {
    const callbacks = [];
    for (const [name, handler] of Object.entries(config)) {
      callbacks.push(this.addListener(name, handler));
    }
    return () => callbacks.forEach((unsubscribe) => unsubscribe());
  }
  removeListener(name, handler) {
    this.listeners[name] = (this.listeners[name] || []).filter((h) => h !== handler);
  }
  clear() {
    this.listeners = {};
  }
  emit(k, ...payload) {
    for (const handler of this.listeners[k] || []) {
      handler(...payload);
    }
    for (const handler of this.listeners[_EventBus.ANY] || []) {
      handler(k, ...payload);
    }
  }
};
var EventBus = _EventBus;
__publicField2(EventBus, "ANY", Math.random().toString().slice(2));
var defer = () => {
  let resolve, reject;
  const p = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return Object.assign(p, { resolve, reject });
};
var _Socket = class {
  constructor(url) {
    __publicField(this, "ws");
    __publicField(this, "url");
    __publicField(this, "ready");
    __publicField(this, "timeout");
    __publicField(this, "queue");
    __publicField(this, "bus");
    __publicField(this, "status");
    __publicField(this, "error");
    __publicField(this, "_onOpen");
    __publicField(this, "_onMessage");
    __publicField(this, "_onError");
    __publicField(this, "_onClose");
    this.url = url;
    this.ready = defer();
    this.queue = [];
    this.bus = new EventBus();
    this.status = _Socket.STATUS.NEW;
    this._onOpen = () => {
      this.error = void 0;
      this.status = _Socket.STATUS.READY;
      this.ready.resolve();
      this.bus.emit("open");
    };
    this._onMessage = (event) => {
      this.queue.push(event.data);
      if (!this.timeout) {
        this.handleMessagesAsync();
      }
    };
    this._onError = (error) => {
      this.error = error;
      this.bus.emit("error", error);
    };
    this._onClose = () => {
      this.disconnect();
      this.ready.reject();
      this.status = _Socket.STATUS.CLOSED;
      this.bus.emit("close");
    };
  }
  async connect() {
    if ([_Socket.STATUS.NEW, _Socket.STATUS.CLOSED].includes(this.status)) {
      if (this.ws) {
        console.error("Attempted to connect when already connected", this);
      }
      this.ready = defer();
      this.ws = new browser_default(this.url);
      this.status = _Socket.STATUS.PENDING;
      this.ws.addEventListener("open", this._onOpen);
      this.ws.addEventListener("message", this._onMessage);
      this.ws.addEventListener("error", this._onError);
      this.ws.addEventListener("close", this._onClose);
    }
    await this.ready.catch(() => null);
  }
  disconnect() {
    if (this.ws) {
      const ws2 = this.ws;
      this.ready.then(() => ws2.close(), () => null);
      this.ws.removeEventListener("open", this._onOpen);
      this.ws.removeEventListener("message", this._onMessage);
      this.ws.removeEventListener("error", this._onError);
      this.ws.removeEventListener("close", this._onClose);
      this.ws = void 0;
    }
  }
  cleanup() {
    this.disconnect();
    this.bus.clear();
  }
  handleMessages() {
    for (const json of this.queue.splice(0, 10)) {
      let message;
      try {
        message = JSON.parse(json);
      } catch (e) {
        continue;
      }
      this.bus.emit("message", this.url, message);
    }
    if (this.queue.length > 0) {
      this.handleMessagesAsync();
    } else {
      this.timeout = void 0;
    }
  }
  handleMessagesAsync() {
    this.timeout = setTimeout(() => this.handleMessages(), 10);
  }
  send(message) {
    var _a, _b;
    if (this.status === _Socket.STATUS.READY) {
      if (((_a = this.ws) == null ? void 0 : _a.readyState) !== 1) {
        console.warn("Send attempted before socket was ready", this);
      }
      (_b = this.ws) == null ? void 0 : _b.send(JSON.stringify(message));
    }
  }
};
var Socket = _Socket;
__publicField2(Socket, "STATUS", {
  NEW: "new",
  PENDING: "pending",
  CLOSED: "closed",
  READY: "ready"
});
var createFilterId = (filters) => [Math.random().toString().slice(2, 6), filters.map(describeFilter).join(":")].join("-");
var describeFilter = ({ kinds = [], ...filter }) => {
  const parts = [];
  parts.push(kinds.join(","));
  for (const [key, value] of Object.entries(filter)) {
    if (value instanceof Array) {
      parts.push(`${key}[${value.length}]`);
    } else {
      parts.push(key);
    }
  }
  return "(" + parts.join(",") + ")";
};
var Executor = class {
  constructor(target) {
    __publicField(this, "target");
    this.target = target;
  }
  subscribe(filters, { onEvent, onEose }) {
    const id = createFilterId(filters);
    const unsubscribe = this.target.bus.addListeners({
      EVENT: (url, subid, e) => subid === id && (onEvent == null ? void 0 : onEvent(url, e)),
      EOSE: (url, subid) => subid === id && (onEose == null ? void 0 : onEose(url))
    });
    this.target.send("REQ", id, ...filters);
    return {
      unsubscribe: () => {
        this.target.send("CLOSE", id);
        unsubscribe();
      }
    };
  }
  publish(event, { onOk, onError }) {
    const unsubscribe = this.target.bus.addListeners({
      OK: (url, id, ...payload) => id === event.id && onOk(url, ...payload),
      ERROR: (url, id, ...payload) => id === event.id && onError(url, ...payload)
    });
    this.target.send("EVENT", event);
    return { unsubscribe };
  }
  count(filters, { onCount }) {
    const id = createFilterId(filters);
    const unsubscribe = this.target.bus.addListeners({
      COUNT: (url, subid, ...payload) => {
        if (subid === id) {
          onCount(url, ...payload);
          unsubscribe();
        }
      }
    });
    this.target.send("COUNT", id, ...filters);
    return { unsubscribe };
  }
  handleAuth({ onAuth, onOk }) {
    let event;
    const unsubscribe = this.target.bus.addListeners({
      AUTH: async (url, challenge) => {
        event = await onAuth(url, challenge);
      },
      OK: (url, id, ok, message) => {
        if (id === (event == null ? void 0 : event.id)) {
          event = null;
          onOk(url, id, ok, message);
        }
      }
    });
    return { unsubscribe };
  }
};
var Plex = class {
  constructor(urls, socket) {
    this.urls = urls;
    this.socket = socket;
    this.bus = new EventBus();
    this.unsubscribe = socket.bus.addListeners({
      message: (websocketUrl, [{ relays }, [verb, ...payload]]) => {
        this.bus.emit(verb, relays[0], ...payload);
      }
    });
  }
  async send(...payload) {
    await this.socket.connect();
    this.socket.send([{ relays: this.urls }, payload]);
  }
  cleanup() {
    this.bus.clear();
    this.unsubscribe();
  }
};
var Pool = class {
  constructor() {
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
    this.bus = new EventBus();
  }
  has(url) {
    return this.data.has(url);
  }
  get(url) {
    if (!this.data.has(url)) {
      const socket = new Socket(url);
      this.data.set(url, socket);
      this.bus.emit("init", { url });
      socket.bus.addListeners({
        open: () => this.bus.emit("open", { url }),
        close: () => this.bus.emit("close", { url })
      });
    }
    return this.data.get(url);
  }
  remove(url) {
    const socket = this.data.get(url);
    if (socket) {
      socket.cleanup();
      this.data.delete(url);
    }
  }
  clear() {
    for (const url of this.data.keys()) {
      this.remove(url);
    }
  }
};
var Relay = class {
  constructor(socket) {
    this.socket = socket;
    this.bus = new EventBus();
    this.listeners = sockets.map((socket2) => {
      return socket2.bus.addListener("message", (url, [verb, ...payload]) => {
        this.bus.emit(verb, url, ...payload);
      });
    });
  }
  async send(...payload) {
    await this.socket.connect();
    this.socket.send(payload);
  }
  cleanup() {
    this.bus.clear();
    this.listeners.map((unsubscribe) => unsubscribe());
  }
};
var Relays = class {
  constructor(sockets2) {
    __publicField(this, "sockets");
    __publicField(this, "bus");
    this.sockets = sockets2;
    this.bus = new EventBus();
    this.listeners = sockets2.map((socket) => {
      return socket.bus.addListener("message", (url, [verb, ...payload]) => {
        this.bus.emit(verb, url, ...payload);
      });
    });
  }
  send(...payload) {
    this.sockets.forEach(async (socket) => {
      await socket.connect();
      socket.send(payload);
    });
  }
  cleanup() {
    this.bus.clear();
    this.listeners.map((unsubscribe) => unsubscribe());
  }
};
export {
  EventBus,
  Executor,
  Plex,
  Pool,
  Relay,
  Relays,
  Socket,
  defer
};
//# sourceMappingURL=paravel.js.map
